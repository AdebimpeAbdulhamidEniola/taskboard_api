This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
prisma.config.ts
prisma/migrations/20260109111709_updated_db_schema/migration.sql
prisma/migrations/20260109170144_update_db/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
src/config/app.ts
src/controllers/boardController.ts
src/controllers/taskController.ts
src/general/handleResponse.ts
src/general/notFoundHandler.ts
src/index.ts
src/lib/prisma.ts
src/middleware/errorHandler.ts
src/middleware/validateRequest.ts
src/model/boardModel.ts
src/model/taskModel.ts
src/routes/boardRoutes.ts
src/routes/taskRoutes.ts
src/schema/apiSchema.ts
src/types/types.ts
src/utils/customError.ts
src/utils/errorHandler.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/middleware/validateRequest.ts">
// src/middleware/validateRequest.ts
import { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';
import { BadRequestError } from '@/utils/customError';

export const validateBody = (schema: ZodSchema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        try {
            const validated = schema.parse(req.body);
            req.body = validated; // Replace with validated data
            next();
        } catch (error) {
            if (error instanceof ZodError) {
                const messages = error.issues.map(issue => issue.message);
                
                next(new BadRequestError(JSON.stringify(messages)));
            } else {
                next(error);
            }
        }
    };
};

export const validateParams = (schema: ZodSchema) => {
    return (req: Request, res: Response, next: NextFunction) => {
        try {
            const validated = schema.parse(req.params);
            req.params = validated as any; // Type assertion to handle Express params type
            next();
        } catch (error) {
            if (error instanceof ZodError) {
                const messages = error.issues.map(issue => issue.message);
                
                next(new BadRequestError(JSON.stringify(messages)));
            } else {
                next(error);
            }
        }
    };
};
</file>

<file path="src/schema/apiSchema.ts">
import {z} from 'zod';
import { TaskStatus } from '@prisma/client';

export const taskSchema = z.object({
    name: z.string({
        error: (issue) => {
            if (issue.input === undefined)
                return 'Task name is required'
            else 
                return 'Task name must be in alphabet'
        }
    })
    .min(3, "Minimum of 3 letters can be used a task name")
    .trim(),

     description: z.string({
        error: (issue) => {
            if (issue.input === undefined)
                return 'Task description is required'
            else 
                return 'Task description must be in alphabet'
        }
    })
    .min(3, "Minimum of 3 letters can be used a task description")
    .trim()
    .optional(),



    status: z.enum(TaskStatus,{error: "Invalid task status"})
})


export const boardSchema = z.object({
    name: z.string({
        error: (issue) => {
            if (issue.input === undefined) return 'Board name is required'
            else return 'Board name must be alphabet'
        }
    }).min(3, "Minimum of 3 letters can be used a board name"),

    description: z.string({
        error: (issue) => {
            if (issue.input === undefined) return 'Board description is required'
            else return 'Board description must be alphabet'
        }
    }).min(3, "Minimum of 3 letters can be used a board description").optional().nullable(),
});


// Parameter validation schemas
export const boardIdSchema = z.object({
    boardId: z.string().min(1, "Board ID is required")
});

// Partial schemas for updates (all fields optional)
export const updateTaskSchema = taskSchema.partial();
export const updateBoardSchema = boardSchema.partial();
</file>

<file path="package.json">
{
  "name": "mytaskboardapi",
  "version": "1.0.0",
  "description": "A RESTful API for task board management",
  "license": "ISC",
  "author": "",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@prisma/adapter-pg": "^7.2.0",
    "@prisma/client": "^7.2.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "pg": "^8.16.3",
    "zod": "^4.3.5"
  },
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/node": "^25.0.3",
    "@types/pg": "^8.16.0",
    "prisma": "^7.2.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="prisma.config.ts">
import "dotenv/config";

const databaseUrl = process.env.DATABASE_URL as string;

if (!databaseUrl) {
  throw new Error("DATABASE_URL environment variable is not set");
}

export default {
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: databaseUrl,
  },
};
</file>

<file path="prisma/migrations/20260109111709_updated_db_schema/migration.sql">
-- CreateTable
CREATE TABLE "Board" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Board_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Task" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "boardId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_boardId_fkey" FOREIGN KEY ("boardId") REFERENCES "Board"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20260109170144_update_db/migration.sql">
/*
  Warnings:

  - You are about to drop the column `title` on the `Task` table. All the data in the column will be lost.
  - Added the required column `name` to the `Task` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "TaskStatus" AS ENUM ('IN_PROGRESS', 'COMPLETED', 'WONT_DO');

-- AlterTable
ALTER TABLE "Task" DROP COLUMN "title",
ADD COLUMN     "name" TEXT NOT NULL,
ADD COLUMN     "status" "TaskStatus" NOT NULL DEFAULT 'IN_PROGRESS';
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/controllers/boardController.ts">
import { Request, Response, NextFunction } from "express";
import { createBoardService,updateBoardService,getBoardByIdService, deleteBoardService } from "@/model/boardModel";
import { handleResponse } from "../general/handleResponse";
import { CreateBoardRequest, BoardParamsRequest, UpdateBoardRequest } from "../types/types";

export const createBoard = async (req: CreateBoardRequest, res: Response, next: NextFunction) => {
  try {
    const { name, description } = req.body;
    const board = await createBoardService(name, description);
    handleResponse(res, 201, "Board created successfully", board);
  } catch (error) {
    next(error);
  }
};

export const getBoard = async (req: BoardParamsRequest, res: Response, next: NextFunction) => {
  try {
    const { boardId } = req.params;
    const board = await getBoardByIdService(boardId);
    handleResponse(res, 200, "Board retrieved successfully", board);
  } catch (error) {
    next(error);
  }
};

export const updateBoard = async (req: UpdateBoardRequest, res: Response, next: NextFunction) => {
  try {
    const { boardId } = req.params;
    const { name, description } = req.body;
    const board = await updateBoardService(boardId, name, description);
    handleResponse(res, 200, "Board updated successfully", board);
  } catch (error) {
    next(error);
  }
};

export const deleteBoard = async (req: BoardParamsRequest, res: Response, next: NextFunction) => {
  try {
    const { boardId } = req.params;
    const board = await deleteBoardService(boardId);
    handleResponse(res, 200, "Board deleted successfully", board);
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/controllers/taskController.ts">
// src/controllers/taskController.ts
import { Response, NextFunction } from "express";
import { handleResponse } from "../general/handleResponse";
import {
  updateTaskService,
  deleteTaskService,
} from "@/model/taskModel";
import {
  TaskParamsRequest,
  UpdateTaskRequest,
} from "../types/types";

// PUT /api/tasks/:taskId
export const updateTask = async (
  req: UpdateTaskRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { taskId } = req.params;
    const { name, description, status } = req.body;

    const task = await updateTaskService(taskId, name, description, status);
    handleResponse(res, 200, "Task updated successfully", task);
  } catch (error) {
    next(error);
  }
};

// DELETE /api/tasks/:taskId
export const deleteTask = async (
  req: TaskParamsRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { taskId } = req.params;

    const result = await deleteTaskService(taskId);
    handleResponse(res, 200, "Task deleted successfully", result);
  } catch (error) {
    next(error);
  }
};
</file>

<file path="src/general/handleResponse.ts">
import { Response } from "express";

export const handleResponse = (
  res: Response,
  statusCode: number,
  message: string,
  data?: unknown
): void => {
  if (data !== undefined) {
    res.status(statusCode).json({
      status: "success",
      message,
      data,
    });

    return;
  }

  res.status(statusCode).json({
    status: "success",
    message,
  });
};
</file>

<file path="src/general/notFoundHandler.ts">
import { Request, Response } from "express";
import { sendErrorResponse } from "../utils/errorHandler";

export const notFoundHandler = (req: Request, res: Response): void => {
  sendErrorResponse(res, 404, `Route ${req.originalUrl} not found`);
};
</file>

<file path="src/index.ts">
import { createApp } from "./config/app";

const app = createApp();

const port = Number(process.env.PORT) 

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
</file>

<file path="src/lib/prisma.ts">
import "dotenv/config";
import { PrismaPg } from "@prisma/adapter-pg";
import { PrismaClient } from "@prisma/client";

const connectionString = `${process.env.DATABASE_URL}`;

const adapter = new PrismaPg({ connectionString });
const prisma = new PrismaClient({ adapter });

prisma.$connect().catch((err: unknown) => {
  console.error("Failed to connect to database:", err);
  process.exit(1);
});

export default prisma;
</file>

<file path="src/model/boardModel.ts">
import prisma from "@/lib/prisma";
import { NotFoundError } from "../utils/customError";


// src/model/boardModel.ts

const DEFAULT_TASKS = [
  {
    name: "Set up project",
    description: "Initialize repo and configuration",
    status: "IN_PROGRESS" as const,  // TaskStatus.IN_PROGRESS
  },
  {
    name: "Invite team members",
    description: "Share this board with your team",
    status: "IN_PROGRESS" as const,
  },
  {
    name: "Create your first real task",
    description: "Replace this with something you actually need to do",
    status: "IN_PROGRESS" as const,
  },
];

const tasksData = DEFAULT_TASKS.map((task) => ({
  name: task.name,
  description: task.description,
  status: task.status,
}));




export const createBoardService = async (
  name: string,
  description?: string
) => {
  const board = await prisma.board.create({
    data: {
      name,
      description,
      tasks: {
        create: tasksData
      }
    },

    include: {
      tasks: true
    }
  });

  return board;
};

export const getBoardByIdService = async (boardId: string) => {
  const board = await prisma.board.findUnique({
    where: { id: boardId },
    include: { tasks: true },
  });

  if (!board) {
    throw new NotFoundError("Board not found");
  }

  return board;
};

export const updateBoardService = async (
  boardId: string,
  name?: string,
  description?: string
) => {
  const updateData: {
    name?: string;
    description?: string | null;
  } = {};
  
  if (name !== undefined) updateData.name = name;
  if (description !== undefined) updateData.description = description;

  const board = await prisma.board.update({
    where: { id: boardId },
    data: updateData,
    include: { tasks: true }
  });

  return board;
};

export const deleteBoardService = async (boardId: string) => {
  await prisma.board.delete({
    where: { id: boardId }
  });

  return { message: 'Board deleted successfully' };
};
</file>

<file path="src/model/taskModel.ts">
// src/model/taskModel.ts
import prisma from "@/lib/prisma";
import { NotFoundError } from "@/utils/customError";

// Update an existing task
export const updateTaskService = async (
  taskId: string,
  name?: string,
  description?: string,
  status?: "IN_PROGRESS" | "COMPLETED" | "WONT_DO"
) => {
  const updateData: {
    name?: string;
    description?: string | null;
    status?: "IN_PROGRESS" | "COMPLETED" | "WONT_DO";
  } = {};

  if (name !== undefined) updateData.name = name;
  if (description !== undefined) updateData.description = description;
  if (status !== undefined) updateData.status = status;

  const task = await prisma.task.update({
    where: { id: taskId },
    data: updateData,
  });

  if (!task) {
    throw new NotFoundError("Task not found");
  }

  return task;
};

// Delete an existing task
export const deleteTaskService = async (taskId: string) => {
  await prisma.task.delete({
    where: { id: taskId },
  });

  return { message: "Task deleted successfully" };
};
</file>

<file path="src/utils/customError.ts">
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;

    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = "Resource not found") {
    super(message, 404);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export class BadRequestError extends AppError {
  constructor(message: string = "Bad request") {
    super(message, 400);
    Object.setPrototypeOf(this, BadRequestError.prototype);
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "lib": [
      "ES2022"
    ],
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "verbatimModuleSyntax": false
  },
  "include": [
    "src/**/*.ts",
    "prisma.config.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path=".gitignore">
node_modules
# Keep environment variables out of version control
.env


/generated/prisma
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum TaskStatus {
  IN_PROGRESS
  COMPLETED
  WONT_DO
}

model Board {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  tasks       Task[]
}

model Task {
  id          String   @id @default(cuid())
  name        String
  description String?
  status      TaskStatus 
  boardId     String
  board       Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
</file>

<file path="src/middleware/errorHandler.ts">
// src/middleware/errorHandler.ts
import { NextFunction, Request, Response } from "express";
import { handleAllErrors } from "../utils/errorHandler";

const errorHandling = (
  err: unknown,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (res.headersSent) {
    return next(err);
  }

  handleAllErrors(err, res);
};

export default errorHandling;
</file>

<file path="src/routes/taskRoutes.ts">
import express from "express";
import {updateTask, deleteTask} from "../controllers/taskController";

const router = express.Router({caseSensitive: true, strict: true});

router.put("/:taskId", updateTask);
router.delete("/:taskId", deleteTask);

export default router;
</file>

<file path="src/types/types.ts">
// src/types/types.ts
import { Request } from "express";

export interface CreateBoardRequestBody {
  name: string;
  description?: string;
}

export interface BoardParams {
  boardId: string;
}

export interface UpdateBoardRequestBody {
  name?: string;
  description?: string;
}

export type CreateBoardRequest = Request<{}, {}, CreateBoardRequestBody>;
export type BoardParamsRequest = Request<BoardParams>;
export type UpdateBoardRequest = Request<BoardParams, {}, UpdateBoardRequestBody>;

// ===== Task types =====
export interface TaskParams {
  taskId: string;
}

export interface UpdateTaskRequestBody {
  name?: string;
  description?: string;
  status?: "IN_PROGRESS" | "COMPLETED" | "WONT_DO";
}

export type TaskParamsRequest = Request<TaskParams>;
export type UpdateTaskRequest = Request<TaskParams, {}, UpdateTaskRequestBody>;
</file>

<file path="src/utils/errorHandler.ts">
// src/utils/errorHandler.ts
import { Prisma } from "@prisma/client";
import { Response } from "express";
import { AppError } from "./customError";

export const sendErrorResponse = (
  res: Response,
  statusCode: number,
  message: string
): void => {
  const isServerError = statusCode >= 500;

  res.status(statusCode).json({
    status: isServerError ? "error" : "failed",
    message,
  });
};

export const catchPrismaError = (error: unknown, res: Response): boolean => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const prismaError = error as Prisma.PrismaClientKnownRequestError;

    if (prismaError.code === "P2002") {
      const field = (prismaError.meta?.target as string[])?.[0];
      sendErrorResponse(res, 409, `A record with this field already exists: ${field}`);
      return true;
    }

    if (prismaError.code === "P2025") {
      sendErrorResponse(res, 404, "Record not found");
      return true;
    }

    if (prismaError.code === "P2003") {
      sendErrorResponse(res, 400, "Foreign key constraint violation");
      return true;
    }

    if (prismaError.code === "P2014") {
      sendErrorResponse(
        res,
        400,
        "Relation violation - cannot delete or update related records"
      );
      return true;
    }

    if (prismaError.code === "P2021") {
      sendErrorResponse(res, 500, "Database table does not exist");
      return true;
    }

    if (prismaError.code === "P2022") {
      sendErrorResponse(res, 500, "Database column does not exist");
      return true;
    }

    // generic Prisma error (treat as server error)
    sendErrorResponse(res, 500, `Database error: ${prismaError.message}`);
    return true;
  }

  return false;
};

export const handleUnexpectedError = (error: unknown, res: Response): void => {
  console.error("Unexpected error:", error);

  // Always server error → status: "error"
  res.status(500).json({
    status: "error",
    message: "An unexpected error occurred",
  });
};

export const handleAppError = (error: unknown, res: Response): boolean => {
  if (error instanceof AppError) {
    // AppError is user / known side → status: "failed"
    sendErrorResponse(res, error.statusCode, error.message);
    return true;
  }
  return false;
};

export const handleAllErrors = (error: unknown, res: Response): void => {
  if (handleAppError(error, res)) return;
  if (catchPrismaError(error, res)) return;
  handleUnexpectedError(error, res);
};
</file>

<file path="src/config/app.ts">
import cors from "cors";
import express, { Application } from "express";
import dotenv from "dotenv";
import taskRoutes from "../routes/taskRoutes";
import errorHandling from "../middleware/errorHandler";
import { notFoundHandler } from "../general/notFoundHandler";
import boardRoutes from "../routes/boardRoutes";



dotenv.config();

export const createApp = (): Application => {
  const app: Application = express();

  app.use(express.json());

  app.use(cors());

  app.use("/api/boards", boardRoutes);
  app.use("/api/tasks", taskRoutes)
  

  app.use(notFoundHandler);



  app.use(errorHandling);

  return app;
};
</file>

<file path="src/routes/boardRoutes.ts">
import express from "express";
import {getBoard, createBoard, updateBoard, deleteBoard} from "../controllers/boardController";


import { validateBody, validateParams } from "@/middleware/validateRequest";
import { boardSchema, updateBoardSchema, boardIdSchema } from "@/schema/apiSchema";
const router = express.Router({caseSensitive: true, strict: true});

router.get("/:boardId", validateParams(boardIdSchema), getBoard);
router.post("/",validateBody(boardSchema), createBoard);
router.put("/:boardId", validateParams(boardIdSchema), validateBody(updateBoardSchema), updateBoard);
router.delete("/:boardId", validateParams(boardIdSchema), deleteBoard);

export default router;
</file>

</files>
